// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#include <gtest/gtest.h>

#include <algorithm>
#include <random>
#include <string>

#include "arrow/io/file.h"
#include "parquet/bloom.h"
#include "parquet/murmur3.h"
#include "parquet/util/memory.h"
#include "parquet/util/test-common.h"

namespace parquet {
namespace test {
TEST(Murmur3Test, TestBloomFilter) {
  int64_t result;
  const uint8_t bitset[8] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7};
  MurmurHash3 murmur3;
  murmur3.Hash_x64_128(bitset, 8, MurmurHash3::DEFAULT_SEED, &result);
  EXPECT_EQ(result, -3850979349427597861l);
}

TEST(FindTest, TestBloomFilter) {
  Bloom bloom(1024);

  for (int i = 0; i < 10; i++) {
    uint64_t hash_value = bloom.Hash(i);
    bloom.InsertHash(hash_value);
  }

  // Serialize bloom filter to memory output stream
  InMemoryOutputStream sink;
  bloom.WriteTo(&sink);

  // Deserialize bloom filter from memory
  InMemoryInputStream source(sink.GetBuffer());
  int64_t bytes_available;
  uint32_t length =
      *(reinterpret_cast<const uint32_t*>(source.Read(4, &bytes_available)));
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), 4);
  EXPECT_EQ(length, 1024);

  uint32_t hash = *(reinterpret_cast<const uint32_t*>(source.Read(4, &bytes_available)));
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), 4);
  EXPECT_EQ(hash, 0);

  uint32_t algo = *(reinterpret_cast<const uint32_t*>(source.Read(4, &bytes_available)));
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), 4);
  EXPECT_EQ(algo, 0);

  const uint8_t* bitset = source.Read(length, &bytes_available);
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), length);
  Bloom de_bloom(bitset, length);
  for (int i = 0; i < 10; i++) {
    EXPECT_TRUE(de_bloom.FindHash(de_bloom.Hash(i)));
  }
}

TEST(FPPTest, TestBloomFilter) {
  // The exist is a counter for Bloom filter check in this test, if Bloom filter
  // FindHash return true, it is increased by one.
  int exist = 0;

  // Total count of elements that will be used
  int total_count = 100000;

  // Bloom filter fpp parameter
  double fpp = 0.01;

  // Character set used to generate random string
  std::string charset("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
  std::vector<std::string> members;
  Bloom bloom(Bloom::OptimalNumOfBits(total_count, fpp));

  // The uuid_seed is generated by "uuidgen -r"
  std::string uuid_seed = "8de406aa-fb59-4195-a81c-5152af26433f";
  std::seed_seq seed(uuid_seed.begin(), uuid_seed.end());
  std::mt19937 generator(seed);

  // Insert 100000 elements to bloom filter and serialize to memory
  for (int i = 0; i < total_count; i++) {
    std::shuffle(charset.begin(), charset.end(), generator);
    std::string tmp = charset.substr(0, 10);
    ByteArray byte_array(10, reinterpret_cast<const uint8_t*>(tmp.c_str()));
    members.push_back(tmp);
    bloom.InsertHash(bloom.Hash<const ByteArray*>(&byte_array));
  }

  InMemoryOutputStream sink;
  bloom.WriteTo(&sink);

  // Deserialize bloom filter from memory
  InMemoryInputStream source(sink.GetBuffer());
  int64_t bytes_available;
  uint32_t length =
      *(reinterpret_cast<const uint32_t*>(source.Read(4, &bytes_available)));
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), 4);

  uint32_t hash = *(reinterpret_cast<const uint32_t*>(source.Read(4, &bytes_available)));
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), 4);
  EXPECT_EQ(hash, 0);

  uint32_t algo = *(reinterpret_cast<const uint32_t*>(source.Read(4, &bytes_available)));
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), 4);
  EXPECT_EQ(algo, 0);

  const uint8_t* bitset = source.Read(length, &bytes_available);
  ASSERT_EQ(static_cast<uint32_t>(bytes_available), length);

  Bloom de_bloom(bitset, length);
  for (int i = 0; i < total_count; i++) {
    ByteArray byte_array1(10, reinterpret_cast<const uint8_t*>(members[i].c_str()));
    ASSERT_TRUE(de_bloom.FindHash(de_bloom.Hash<const ByteArray*>(&byte_array1)));
    std::shuffle(charset.begin(), charset.end(), generator);
    std::string tmp = charset.substr(0, 8);
    ByteArray byte_array2(8, reinterpret_cast<const uint8_t*>(tmp.c_str()));

    if (de_bloom.FindHash(de_bloom.Hash<const ByteArray*>(&byte_array2))) {
      exist++;
    }
  }

  // The exist should be probably less than 1000 according default FPP 0.01.
  EXPECT_TRUE(exist < total_count * fpp);
}

// The CompatibilityTest is use to test cross compatibility with parquet-mr, it read
// the Bloom filter generated by Bloom filter class in parquet-mr project and test
// whether the values inserted before could be filtered or not.
TEST(CompatibilityTest, TestBloomFilter) {
  int64_t bytesRead;
  int length, hash, algorithm;
  std::unique_ptr<uint8_t[]> bitset;

  std::string testString[4] = {"hello", "parquet", "bloom", "filter"};
  std::string data_dir(test::get_data_dir());
  std::string bloomDataPath = data_dir + "/bloom_filter.bin";
  std::shared_ptr<::arrow::io::ReadableFile> handle;

  PARQUET_THROW_NOT_OK(::arrow::io::ReadableFile::Open(bloomDataPath, &handle));

  handle->Read(4, &bytesRead, reinterpret_cast<void*>(&length));
  ASSERT_EQ(bytesRead, 4);
  handle->Read(4, &bytesRead, reinterpret_cast<void*>(&hash));
  ASSERT_EQ(hash, 0);
  handle->Read(4, &bytesRead, reinterpret_cast<void*>(&algorithm));
  ASSERT_EQ(algorithm, 0);

  bitset.reset(new uint8_t[length]);
  handle->Read(length, &bytesRead, reinterpret_cast<void*>(bitset.get()));
  ASSERT_TRUE(length == bytesRead);

  Bloom bloom_filter(bitset.get(), length);

  for (int i = 0; i < 4; i++) {
    ByteArray tmp(static_cast<uint32_t>(testString[i].length()),
                  reinterpret_cast<const uint8_t*>(testString[i].c_str()));
    EXPECT_TRUE(bloom_filter.FindHash(bloom_filter.Hash<const ByteArray*>(&tmp)));
  }
}

}  // namespace test

}  // namespace parquet
