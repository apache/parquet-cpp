// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#include <gtest/gtest.h>

#include <algorithm>
#include <random>
#include <string>

#include "arrow/io/file.h"
#include "parquet/bloom_filter.h"
#include "parquet/murmur3.h"
#include "parquet/util/memory.h"
#include "parquet/util/test-common.h"

namespace parquet {
namespace test {
TEST(Murmur3Test, TestBloomFilter) {
  uint64_t result;
  const uint8_t bitset[8] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7};
  ByteArray byteArray(8, bitset);
  MurmurHash3 murmur3;
  result = murmur3.Hash(&byteArray);
  EXPECT_EQ(result, UINT64_C(14595764724281953755));
}

TEST(ConstructorTest, TestBloomFilter) {
  EXPECT_NO_THROW(BloomFilter bloom_filter1(1000));
  EXPECT_THROW(new BloomFilter(NULL, 0), ParquetException);
  std::unique_ptr<uint32_t[]> bitset(new uint32_t[1024]());
  EXPECT_THROW(new BloomFilter(bitset.get(), 1023), ParquetException);
}

// The BasicTest is used to test basic operations including InsertHash, FindHash and
// serializing and de-serializing.
TEST(BasicTest, TestBloomFilter) {
  BloomFilter bloom_filter(1024);

  for (int i = 0; i < 10; i++) {
    uint64_t hash_value = bloom_filter.Hash(i);
    bloom_filter.InsertHash(hash_value);
  }

  // Serialize Bloom filter to memory output stream
  InMemoryOutputStream sink;
  bloom_filter.WriteTo(&sink);

  // Deserialize Bloom filter from memory
  InMemoryInputStream source(sink.GetBuffer());

  int64_t bytes_available;
  const uint32_t length = *(reinterpret_cast<const uint32_t*>(
	source.Read(sizeof(uint32_t), &bytes_available)));
  EXPECT_EQ(static_cast<uint32_t>(bytes_available), sizeof(uint32_t));
  EXPECT_EQ(length, 1024);

  const uint32_t hash = *(reinterpret_cast<const uint32_t*>(
	source.Read(sizeof(uint32_t), &bytes_available)));
  EXPECT_EQ(static_cast<uint32_t>(bytes_available), sizeof(uint32_t));
  EXPECT_EQ(hash, 0);

  const uint32_t algo = *(reinterpret_cast<const uint32_t*>(
	source.Read(sizeof(uint32_t), &bytes_available)));
  EXPECT_EQ(static_cast<uint32_t>(bytes_available), sizeof(uint32_t));
  EXPECT_EQ(algo, 0);

  const uint8_t* bitset = source.Read(length, &bytes_available);
  EXPECT_EQ(static_cast<uint32_t>(bytes_available), length);

  BloomFilter de_bloom(reinterpret_cast<const uint32_t *>(bitset), length);
  for (int i = 0; i < 10; i++) {
    EXPECT_TRUE(de_bloom.FindHash(de_bloom.Hash(i)));
  }
}

// Helper function to generate random string.
std::string GetRandomString(uint32_t length) {
  // Character set used to generate random string
  const std::string charset =
      "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

  // The uuid_seed was generated by "uuidgen -r"
  const std::string uuid_seed = "8de406aa-fb59-4195-a81c-5152af26433f";
  std::seed_seq seed(uuid_seed.begin(), uuid_seed.end());
  std::mt19937 generator(seed);
  std::uniform_int_distribution<uint32_t> dist(0, static_cast<int>(charset.size() - 1));
  std::string ret = "";

  for (uint32_t i = 0; i < length; i++) {
    uint32_t random_index = dist(generator);
    ret += charset[random_index];
  }

  return ret;
}

TEST(FPPTest, TestBloomFilter) {
  // The exist is counter for the Bloom filter check in this test, if
  // FindHash returns true, it is increased by one.
  int exist = 0;

  // Total count of elements that will be used
  const int total_count = 100000;

  // Bloom filter fpp parameter
  const double fpp = 0.01;

  std::vector<std::string> members;
  BloomFilter bloom_filter(BloomFilter::OptimalNumOfBits(total_count, fpp));

  // Insert elements into the Bloom filter and serialize to memory
  for (int i = 0; i < total_count; i++) {
    // Insert random string which length is 8
    std::string tmp = GetRandomString(8);
    ByteArray byte_array(8, reinterpret_cast<const uint8_t*>(tmp.c_str()));
    members.push_back(tmp);
    bloom_filter.InsertHash(bloom_filter.Hash<const ByteArray*>(&byte_array));
  }

  for (int i = 0; i < total_count; i++) {
    ByteArray byte_array1(8, reinterpret_cast<const uint8_t*>(members[i].c_str()));
    ASSERT_TRUE(bloom_filter.FindHash(bloom_filter.Hash<const ByteArray*>(&byte_array1)));
    std::string tmp = GetRandomString(7);
    ByteArray byte_array2(7, reinterpret_cast<const uint8_t*>(tmp.c_str()));

    if (bloom_filter.FindHash(bloom_filter.Hash<const ByteArray*>(&byte_array2))) {
      exist++;
    }
  }

  // The exist should be probably less than 1000 according default FPP 0.01.
  EXPECT_TRUE(exist < total_count * fpp);
}

// The CompatibilityTest is used to test cross compatibility with parquet-mr, it reads
// the Bloom filter binary generated by the Bloom filter class in the parquet-mr project
// and tests whether the values inserted before could be filtered or not.

// The Bloom filter binary is generated by three steps in from Parquet-mr.
// Step 1: Construct a Bloom filter with 1024 bytes bitset.
// Step 2: Insert "hello", "parquet", "bloom", "filter" to Bloom filter.
// Step 3: Call writeTo API to write to File.
TEST(CompatibilityTest, TestBloomFilter) {
  int64_t bytes_read;
  int length, hash, algorithm;
  std::unique_ptr<uint8_t[]> bitset;

  const std::string test_string[4] = {"hello", "parquet", "bloom", "filter"};
  std::string data_dir(test::get_data_dir());
  std::string bloom_data_path = data_dir + "/bloom_filter.bin";
  std::shared_ptr<::arrow::io::ReadableFile> handle;

  PARQUET_THROW_NOT_OK(::arrow::io::ReadableFile::Open(bloom_data_path, &handle));

  handle->Read(sizeof(uint32_t), &bytes_read, reinterpret_cast<void*>(&length));
  ASSERT_EQ(bytes_read, sizeof(uint32_t));
  handle->Read(sizeof(uint32_t), &bytes_read, reinterpret_cast<void*>(&hash));
  ASSERT_EQ(hash, 0);
  handle->Read(4, &bytes_read, reinterpret_cast<void*>(&algorithm));
  ASSERT_EQ(algorithm, 0);

  bitset.reset(new uint8_t[length]);
  handle->Read(length, &bytes_read, reinterpret_cast<void*>(bitset.get()));
  ASSERT_TRUE(length == bytes_read);

  BloomFilter bloom_filter(reinterpret_cast<const uint32_t*>(bitset.get()), length);

  for (int i = 0; i < 4; i++) {
    ByteArray tmp(static_cast<uint32_t>(test_string[i].length()),
                  reinterpret_cast<const uint8_t*>(test_string[i].c_str()));
    EXPECT_TRUE(bloom_filter.FindHash(bloom_filter.Hash<const ByteArray*>(&tmp)));
  }

  BloomFilter bloom_filter2(length);
  for (int i = 0; i < 4; i++) {
	ByteArray byte_array(static_cast<uint32_t>(test_string[i].size()),
      reinterpret_cast<const uint8_t*>(test_string[i].c_str()));
    bloom_filter2.InsertHash(bloom_filter2.Hash(&byte_array));
  }

  for (int i = 0; i < 4; i++) {
    ByteArray tmp(static_cast<uint32_t>(test_string[i].length()),
                  reinterpret_cast<const uint8_t*>(test_string[i].c_str()));
    EXPECT_TRUE(bloom_filter2.FindHash(bloom_filter.Hash<const ByteArray*>(&tmp)));
  }

  // Serialize Bloom filter to memory output stream
  InMemoryOutputStream sink;
  bloom_filter2.WriteTo(&sink);
  std::shared_ptr<Buffer> buffer1 = sink.GetBuffer();

  int64_t size;
  handle->Seek(0);
  handle->GetSize(&size);
  std::shared_ptr<Buffer> buffer2;
  handle->Read(size, &buffer2);

  EXPECT_TRUE((*buffer1).Equals(*buffer2));
}

// OptmialValueTest is used to test whether the formula to get optimal number
// of bit for specified ndv and fpp is expected according to Bloom filter
// calculation from
// https://docs.google.com/spreadsheets/d/1LQqGZ1EQSkPBXtdi9nyANiQOhwNFwqiiFe8Sazclf5Y/edit#gid=0
TEST(OptimalValueTest, TestBloomFilter) {
  EXPECT_TRUE(BloomFilter::OptimalNumOfBits(256, 0.01) > 2048);
  EXPECT_TRUE(BloomFilter::OptimalNumOfBits(512, 0.01) > 4096);
  EXPECT_TRUE(BloomFilter::OptimalNumOfBits(1024, 0.01) > 8192);
  EXPECT_TRUE(BloomFilter::OptimalNumOfBits(2048, 0.01) > 16384);
}

}  // namespace test

}  // namespace parquet
